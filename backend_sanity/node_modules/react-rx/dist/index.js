import { c } from "react-compiler-runtime";
import { useSyncExternalStore, useState, useEffect } from "react";
import { catchError, finalize, share, timer, asapScheduler, of } from "rxjs";
import { map, tap } from "rxjs/operators";
import { observableCallback } from "observable-callback";
import { useEffectEvent } from "use-effect-event";
function getValue(value) {
  return typeof value == "function" ? value() : value;
}
const cache = /* @__PURE__ */ new WeakMap();
function useObservable(observable, initialValue) {
  const $ = c(9);
  if (!cache.has(observable)) {
    const entry = {
      snapshot: getValue(initialValue)
    };
    entry.observable = observable.pipe(map(_temp$1), catchError(_temp2), tap((t02) => {
      const {
        snapshot,
        error: error_0
      } = t02;
      entry.snapshot = snapshot, entry.error = error_0;
    }), map(_temp3), finalize(() => cache.delete(observable)), share({
      resetOnRefCountZero: _temp4
    })), entry.observable.subscribe().unsubscribe(), cache.set(observable, entry);
  }
  let t0;
  $[0] !== observable ? (t0 = cache.get(observable), $[0] = observable, $[1] = t0) : t0 = $[1];
  const instance = t0;
  let t1;
  $[2] !== instance.observable ? (t1 = (onStoreChange) => {
    const subscription_0 = instance.observable.subscribe(onStoreChange);
    return () => {
      subscription_0.unsubscribe();
    };
  }, $[2] = instance.observable, $[3] = t1) : t1 = $[3];
  const subscribe = t1;
  let t2;
  $[4] !== instance.error || $[5] !== instance.snapshot ? (t2 = () => {
    if (instance.error)
      throw instance.error;
    return instance.snapshot;
  }, $[4] = instance.error, $[5] = instance.snapshot, $[6] = t2) : t2 = $[6];
  let t3;
  return $[7] !== initialValue ? (t3 = typeof initialValue > "u" ? void 0 : () => getValue(initialValue), $[7] = initialValue, $[8] = t3) : t3 = $[8], useSyncExternalStore(subscribe, t2, t3);
}
function _temp4() {
  return timer(0, asapScheduler);
}
function _temp3(value_0) {
}
function _temp2(error) {
  return of({
    snapshot: void 0,
    error
  });
}
function _temp$1(value) {
  return {
    snapshot: value,
    error: void 0
  };
}
function useObservableEvent(handleEvent) {
  const $ = c(6), [t0] = useState(_temp), [calls$, call] = t0;
  let t1;
  $[0] !== handleEvent ? (t1 = (observable) => handleEvent(observable), $[0] = handleEvent, $[1] = t1) : t1 = $[1];
  const onEvent = useEffectEvent(t1);
  let t2, t3;
  return $[2] !== calls$ || $[3] !== onEvent ? (t2 = () => {
    const subscription = calls$.pipe((observable_0) => onEvent(observable_0)).subscribe();
    return () => subscription.unsubscribe();
  }, t3 = [calls$, onEvent], $[2] = calls$, $[3] = onEvent, $[4] = t2, $[5] = t3) : (t2 = $[4], t3 = $[5]), useEffect(t2, t3), call;
}
function _temp() {
  return observableCallback();
}
export {
  useObservable,
  useObservableEvent
};
//# sourceMappingURL=index.js.map
