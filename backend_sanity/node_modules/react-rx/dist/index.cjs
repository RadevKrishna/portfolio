"use strict";
Object.defineProperty(exports, "__esModule", { value: !0 });
var reactCompilerRuntime = require("react-compiler-runtime"), react = require("react"), rxjs = require("rxjs"), operators = require("rxjs/operators"), observableCallback = require("observable-callback"), useEffectEvent = require("use-effect-event");
function getValue(value) {
  return typeof value == "function" ? value() : value;
}
const cache = /* @__PURE__ */ new WeakMap();
function useObservable(observable, initialValue) {
  const $ = reactCompilerRuntime.c(9);
  if (!cache.has(observable)) {
    const entry = {
      snapshot: getValue(initialValue)
    };
    entry.observable = observable.pipe(operators.map(_temp$1), rxjs.catchError(_temp2), operators.tap((t02) => {
      const {
        snapshot,
        error: error_0
      } = t02;
      entry.snapshot = snapshot, entry.error = error_0;
    }), operators.map(_temp3), rxjs.finalize(() => cache.delete(observable)), rxjs.share({
      resetOnRefCountZero: _temp4
    })), entry.observable.subscribe().unsubscribe(), cache.set(observable, entry);
  }
  let t0;
  $[0] !== observable ? (t0 = cache.get(observable), $[0] = observable, $[1] = t0) : t0 = $[1];
  const instance = t0;
  let t1;
  $[2] !== instance.observable ? (t1 = (onStoreChange) => {
    const subscription_0 = instance.observable.subscribe(onStoreChange);
    return () => {
      subscription_0.unsubscribe();
    };
  }, $[2] = instance.observable, $[3] = t1) : t1 = $[3];
  const subscribe = t1;
  let t2;
  $[4] !== instance.error || $[5] !== instance.snapshot ? (t2 = () => {
    if (instance.error)
      throw instance.error;
    return instance.snapshot;
  }, $[4] = instance.error, $[5] = instance.snapshot, $[6] = t2) : t2 = $[6];
  let t3;
  return $[7] !== initialValue ? (t3 = typeof initialValue > "u" ? void 0 : () => getValue(initialValue), $[7] = initialValue, $[8] = t3) : t3 = $[8], react.useSyncExternalStore(subscribe, t2, t3);
}
function _temp4() {
  return rxjs.timer(0, rxjs.asapScheduler);
}
function _temp3(value_0) {
}
function _temp2(error) {
  return rxjs.of({
    snapshot: void 0,
    error
  });
}
function _temp$1(value) {
  return {
    snapshot: value,
    error: void 0
  };
}
function useObservableEvent(handleEvent) {
  const $ = reactCompilerRuntime.c(6), [t0] = react.useState(_temp), [calls$, call] = t0;
  let t1;
  $[0] !== handleEvent ? (t1 = (observable) => handleEvent(observable), $[0] = handleEvent, $[1] = t1) : t1 = $[1];
  const onEvent = useEffectEvent.useEffectEvent(t1);
  let t2, t3;
  return $[2] !== calls$ || $[3] !== onEvent ? (t2 = () => {
    const subscription = calls$.pipe((observable_0) => onEvent(observable_0)).subscribe();
    return () => subscription.unsubscribe();
  }, t3 = [calls$, onEvent], $[2] = calls$, $[3] = onEvent, $[4] = t2, $[5] = t3) : (t2 = $[4], t3 = $[5]), react.useEffect(t2, t3), call;
}
function _temp() {
  return observableCallback.observableCallback();
}
exports.useObservable = useObservable;
exports.useObservableEvent = useObservableEvent;
//# sourceMappingURL=index.cjs.map
